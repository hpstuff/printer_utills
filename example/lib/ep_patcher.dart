// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  NativeLibrary.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// <summary>
  /// <param>char *PrinterName � Name of the printer to use</param>
  /// <returns>Pointer to internal data structure, NULL if error.</returns>
  /// </summary>
  ffi.Pointer<ffi.Void> Init(
    ffi.Pointer<ffi.Char> PrinterName,
  ) {
    return _Init(
      PrinterName,
    );
  }

  late final _InitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>>('Init');
  late final _Init = _InitPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>)>();

  /// <summary>
  /// <param>void *Data � pointer to internal data from Init.</param>
  /// <param>int Setting � ID representing what setting is getting queried for its value.</param>
  /// <param>char *Value � Holds the setting value, can be NULL.</param>
  /// <param>int BufferSize � required Size for Value buffer, can be NULL.</param>
  /// <returns>0 if OK, error otherwise.</returns>
  /// </summary>
  int GetCurrentValueForSetting(
    ffi.Pointer<ffi.Void> Data,
    int Setting,
    ffi.Pointer<ffi.Char> Value,
    ffi.Pointer<ffi.Int> BufferSize,
  ) {
    return _GetCurrentValueForSetting(
      Data,
      Setting,
      Value,
      BufferSize,
    );
  }

  late final _GetCurrentValueForSettingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('GetCurrentValueForSetting');
  late final _GetCurrentValueForSetting =
      _GetCurrentValueForSettingPtr.asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>();

  /// <summary>
  /// <param>void *Data � pointer to internal data from Init.</param>
  /// <param>int Setting � ID representing what setting is getting queried for its values.</param>
  /// <param>char *Values � Semicolon separated available values for queries setting, can be NULL.</param>
  /// <param>int BufferSize � required Size for Values buffer, can be NULL.</param>
  /// <returns>0 if OK, error otherwise.</returns>
  /// </summary>
  int GetAvailableValuesForSetting(
    ffi.Pointer<ffi.Void> Data,
    int Setting,
    ffi.Pointer<ffi.Char> Values,
    ffi.Pointer<ffi.Int> BufferSize,
  ) {
    return _GetAvailableValuesForSetting(
      Data,
      Setting,
      Values,
      BufferSize,
    );
  }

  late final _GetAvailableValuesForSettingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>>('GetAvailableValuesForSetting');
  late final _GetAvailableValuesForSetting =
      _GetAvailableValuesForSettingPtr.asFunction<
          int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Int>)>();

  /// <summary>
  /// <param>void *Data � pointer to internal data from Init.</param>
  /// <param>int Setting � ID representing what setting is being set.</param>
  /// <param>char *Value � New setting value.</param>
  /// <returns>0 if OK, error otherwise.</returns>
  /// </summary>
  int SetValueForSetting(
    ffi.Pointer<ffi.Void> Data,
    int Setting,
    ffi.Pointer<ffi.Char> Value,
  ) {
    return _SetValueForSetting(
      Data,
      Setting,
      Value,
    );
  }

  late final _SetValueForSettingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('SetValueForSetting');
  late final _SetValueForSetting = _SetValueForSettingPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, int, ffi.Pointer<ffi.Char>)>();

  /// <summary>
  /// Cleanup must be called so that handle to the opened printer is closed.
  /// <param>void *Data � pointer to internal data from Init</param>
  /// </summary>
  int Cleanup(
    ffi.Pointer<ffi.Void> Data,
  ) {
    return _Cleanup(
      Data,
    );
  }

  late final _CleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Void>)>>(
          'Cleanup');
  late final _Cleanup =
      _CleanupPtr.asFunction<int Function(ffi.Pointer<ffi.Void>)>();

  /// <summary>
  /// GetDriverVersion returns dll version of the driver.
  /// <param>void *Data � pointer to internal data from Init</param>
  /// <param>wchar_t *Version � pointer to a buffer that receives Version string</param>
  /// </summary>
  int GetDriverVersion(
    ffi.Pointer<ffi.Void> Data,
    ffi.Pointer<ffi.Int> Version,
  ) {
    return _GetDriverVersion(
      Data,
      Version,
    );
  }

  late final _GetDriverVersionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Int>)>>('GetDriverVersion');
  late final _GetDriverVersion = _GetDriverVersionPtr.asFunction<
      int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Int>)>();

  /// <summary>
  /// <param>char *PrinterName � Name of the printer to use</param>
  /// <param>WORD LanguageId � Language to be used for translations(resources).</param>
  /// <returns>Pointer to internal data structure, NULL if error.</returns>
  /// </summary>
  ffi.Pointer<ffi.Void> InitEx(
    ffi.Pointer<ffi.Char> PrinterName,
    int LanguageId,
  ) {
    return _InitEx(
      PrinterName,
      LanguageId,
    );
  }

  late final _InitExPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Char>, ffi.Int)>>('InitEx');
  late final _InitEx = _InitExPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Char>, int)>();
}

abstract class EErrorID {
  static const int EID_OK = 0;
  static const int EID_Unknown = 1;
  static const int EID_GetDM = 2;
  static const int EID_InvalidDM = 3;
  static const int EID_OutOfMemory = 4;
  static const int EID_APIFailure = 5;
  static const int EID_BufferTooSmall = 6;
  static const int EID_WrongData = 7;
  static const int EID_NullPointer = 8;
  static const int EID_DriverError = 9;
  static const int EID_UnsupportedValue = 10;
  static const int EID_UnknownDrvVersion = 11;
}

const int PATCH_LABEL_HEIGHT = 1;

const int PATCH_LABEL_WIDTH = 2;

const int PATCH_MEDIA_TYPE = 3;

const int PATCH_SPEED = 4;

const int PATCH_PRINT_MODE = 5;

const int PATCH_ORIENTATION = 6;

const int PATCH_MEDIA_HANDLING = 7;

const int PATCH_DARKNESS = 8;

const int PATCH_ERROR_REPORTING = 9;

const int PATCH_CODE_PAGE = 10;

const int PATCH_TEAR_OFF = 11;

const int PATCH_BACKFEED = 12;

const int PATCH_TOF_BACKUP = 13;

const int PATCH_PANEL = 14;

const int PATCH_MEDIA_ACTION = 15;

const int PATCH_MIRROR_IMAGE = 16;

const int PATCH_LABEL_SHIFT = 17;

const int PATCH_REAL_TIME_CLOCK = 18;

const int PATCH_SET_TIME_DATE = 19;

const int PATCH_FORMAT_TIME = 20;

const int PATCH_FORMAT_DATE = 21;

const int PATCH_MODE = 22;

const int PATCH_OFFSET = 23;

const int PATCH_PRINTER_TYPE = 24;

const int PATCH_DPI = 25;

const int PATCH_SPEEDUNIT = 26;

const int PATCH_GAP_LEN = 27;

const int PATCH_GAP_OFFSET = 28;

const int PATCH_MEASURE_UNIT = 29;

const int PATCH_CUTTER = 30;

const int PATCH_PAUSE_AFTER = 31;

const int PATCH_PAUSE_AMOUNT = 32;

const int PATCH_USE_FEED_BUTTON = 33;

const int PATCH_FEED_BUTTON_AMOUNT = 34;

const int PATCH_PAPER_FEED = 35;

const int PATCH_PAPER_FEED_AMOUNT = 36;

const int PATCH_DELAY_BEFORE_FEED = 37;

const int PATCH_DELAY_AMOUNT = 38;

const int PRTYPE_ZPL = 201;

const int PRTYPE_EPL = 203;

const int PRTYPE_COMTEC = 231;

const int PRTYPE_KIOSK = 508;
